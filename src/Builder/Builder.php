<?php
declare(strict_types=1);

namespace JDWil\PhpGenny\Builder;

use JDWil\PhpGenny\Builder\Node\AbstractNode;
use JDWil\PhpGenny\Builder\Node\AbstractNodeContainer;
use JDWil\PhpGenny\Builder\Node\BinaryOp;
use JDWil\PhpGenny\Builder\Node\Body;
use JDWil\PhpGenny\Builder\Node\Class_;
use JDWil\PhpGenny\Builder\Node\If_;
use JDWil\PhpGenny\Builder\Node\Namespace_;
use JDWil\PhpGenny\Builder\Node\NestedNodeInterface;
use JDWil\PhpGenny\Builder\Node\NewInstance;
use JDWil\PhpGenny\Builder\Node\Node;
use JDWil\PhpGenny\Builder\Node\Parameter;
use JDWil\PhpGenny\Builder\Node\ResultTypeInterface;
use JDWil\PhpGenny\Builder\Node\Scalar;
use JDWil\PhpGenny\Builder\Node\Traits\InternalFunctionTrait;
use JDWil\PhpGenny\Builder\Node\Traits\NestedNodeTrait;
use JDWil\PhpGenny\Builder\Node\Traits\NodeBehaviorTrait;
use JDWil\PhpGenny\Builder\Node\Type;
use JDWil\PhpGenny\Builder\Node\Variable;
use JDWil\PhpGenny\Type\Method;
use JDWil\PhpGenny\ValueObject\InternalType;
use JDWil\PhpGenny\ValueObject\Visibility;
use PhpParser\Node\Expr\Print_;
use PhpParser\Node\Name;
use PhpParser\Node\Stmt\Declare_;
use PhpParser\Node\Stmt\DeclareDeclare;
use PhpParser\Node\Stmt\Echo_;
use PhpParser\Node\Stmt\Return_;
use PhpParser\Node\Stmt\Use_;
use PhpParser\Node\Stmt\UseUse;

class Builder extends AbstractNodeContainer
{
    use NestedNodeTrait;
    use InternalFunctionTrait;
    use NodeBehaviorTrait;

    const PHP_53 = 53;
    const PHP_54 = 54;
    const PHP_55 = 55;
    const PHP_56 = 56;
    const PHP_70 = 70;
    const PHP_71 = 71;

    /**
     * @var bool
     */
    protected $useStrict;

    /**
     * @var bool
     */
    protected $preferDefaultsSetInConstructor;

    public function __construct()
    {
        parent::__construct();

        $this->nodes = [];
        $this->useStrict = false;
        $this->preferDefaultsSetInConstructor = false;
    }

    public function __call(string $name, array $arguments)
    {
        if ($func = static::handleInternalFunctionCall($name, $arguments)) {
            $this->nodes[] = $func;
        }
    }

    /**
     * @return $this
     */
    public function useStrictTypes()
    {
        $this->useStrict = true;

        return $this;
    }

    /**
     * @return $this
     */
    public function preferDefaultsSetInConstructor()
    {
        $this->preferDefaultsSetInConstructor = true;

        return $this;
    }

    public function parameter(string $name)
    {
        return Parameter::named($name);
    }

    /**
     * @param AbstractNode $node
     * @return If_
     */
    public function if(AbstractNode $node): If_
    {
        $if = If_::new($node);
        $if->setParent($this);
        $this->nodes[] = $if;

        return $if;
    }

    public function print($value)
    {
        $this->nodes[] = Node::new(Print_::class, [$value]);

        return $this;
    }

    public function echo($value)
    {
        $this->nodes[] = Node::new(Echo_::class, [$value]);

        return $this;
    }

    public function use(string $value, string $alias = null)
    {
        $this->nodes[] = Node::new(Use_::class, [[new UseUse(new Name($value), $alias)]]);

        return $this;
    }

    public function useFunction(string $fqn, string $alias = null)
    {
        $this->nodes[] = Node::new(Use_::class, [[new UseUse(new Name($fqn), $alias, Use_::TYPE_FUNCTION)]]);

        return $this;
    }

    public function declare(string $key, Scalar $value)
    {
        $this->nodes[] = Node::new(Declare_::class, [[new DeclareDeclare($key, $value->getStatements())]]);

        return $this;
    }

    public function execute(AbstractNode $node)
    {
        $this->nodes[] = $node;

        return $this;
    }

    public function class(string $name)
    {
        $c = Class_::new($name);
        $c->setParent($this);
        if ($this->autoGenerateDocBlocks) {
            $c->autoGenerateDocBlocks();
        }

        $this->nodes[] = $c;

        return $c;
    }

    /**
     * @param string $name
     * @return Namespace_
     * @throws \Exception
     */
    public function namespace(string $name): Namespace_
    {
        $this->throwIfNotGlobalScope();

        $namespace = Namespace_::named($name);
        $namespace->setParent($this);
        $this->nodes[] = $namespace;

        return $namespace;
    }

    /**
     * @param AbstractNode $node
     * @return $this
     */
    public function return(AbstractNode $node)
    {
        $this->nodes[] = Node::new(Return_::class, [$node]);

        return $this;
    }

    public function buildClass(\JDWil\PhpGenny\Type\Class_ $class)
    {
        if ($this->useStrict) {
            $this->declare('strict_types', Scalar::int(1));
        }

        $ns = null !== $class->getNamespace() ?
            $this->namespace($class->getNamespace()) :
            $this
        ;

        $uses = $this->collectClassUseStatements($class);
        foreach ($uses as $use) {
            $ns->use($use);
        }

        $c = $ns->class($class->getName());

        if ($class->isAbstract()) {
            $c->makeAbstract();
        }

        if ($class->isFinal()) {
            $c->makeFinal();
        }

        if ($extends = $class->getExtends()) {
            $c->extends($extends);
        }

        $implements = $class->getImplements();
        if (!empty($implements)) {
            foreach ($implements as $i) {
                $c->implements($i);
            }
        }

        $constants = $class->getConstants();
        if (!empty($constants)) {
            foreach ($constants as $constant) {
                $cb = $c->constant($constant['name'], $constant['value']);
                if (null !== $constant['visibility']) {
                    switch ((string) $constant['visibility']) {
                        case Visibility::PUBLIC:
                            $cb->makePublic();
                            break;
                        case Visibility::PROTECTED:
                            $cb->makeProtected();
                            break;
                        case Visibility::PRIVATE:
                            $cb->makePrivate();
                            break;
                    }
                }

                if ($constant['static']) {
                    $cb->makeStatic();
                }
            }
        }

        $properties = $class->getProperties();
        if (!empty($properties)) {
            foreach ($properties as $property) {
                $p = $c->property($property->getName());
                if ($this->preferDefaultsSetInConstructor) {
                    if ($default = $property->getDefaultValue()) {
                        if ($default instanceof \JDWil\PhpGenny\Type\Class_) {
                            $p->setType($default);
                            $constructor = $this->getConstructor($class);
                            $constructor->getBody()->execute(
                                Variable::named('this')->property($property->getName())->equals(NewInstance::of($default->getName()))
                            );
                        } else if ($default instanceof AbstractNode) {
                            if ($default instanceof ResultTypeInterface) {
                                $p->setType($default->getResultType());
                            }
                            $constructor = $this->getConstructor($class);
                            $constructor->getBody()->execute(
                                Variable::named('this')->property($property->getName())->equals($default)
                            );
                        }
                    }
                } else if (($default = $property->getDefaultValue()) && $default instanceof AbstractNode) {
                    $p->setDefault($default);
                }
            }
        }

        $methods = $class->getMethods();
        usort($methods, function (Method $a, Method $b) {
            if ($a->getName() === '__construct') {
                return -1;
            }

            if ($b->getName() === '__construct') {
                return 1;
            }

            return 0;
        });

        if (!empty($methods)) {
            foreach ($methods as $method) {
                $m = $c->method($method->getName());

                foreach ($method->getParameters() as $parameter) {
                    $p = $this->parameter($parameter->getName());
                    if ($type = $parameter->getType()) {
                        $p->setType($type);
                    }

                    if ($default = $parameter->getDefaultValue()) {
                        $p->setDefault($default);
                    }

                    $m->add($p);

                    if ($this->autoGenerateDocBlocks) {
                        $type = $parameter->getType() ?? InternalType::mixed();
                        $m->addComment('@param ' . (string) $type . ' $' . $parameter->getName());
                    }
                }

                $returnTypes = $method->getReturnTypes();
                if (!empty($returnTypes)) {
                    if (count($returnTypes) === 1) {
                        $m->setReturnType($returnTypes[0]);
                        $m->addComment('@return ' . (string) $returnTypes[0]);
                    } else if (
                        count($returnTypes) === 2 &&
                        (
                            ((string) $returnTypes[0]) === 'null' ||
                            ((string) $returnTypes[1]) === 'null'
                        )
                    ) {
                        $nonNullType = (string) $returnTypes[0] === 'null' ?
                            $returnTypes[1] :
                            $returnTypes[0]
                        ;
                        $m->setReturnType($nonNullType, true);
                        $m->addComment('@return ' . (string) $nonNullType . '|null');
                    } else {
                        $types = [];
                        foreach ($returnTypes as $returnType) {
                            $types[] = (string) $returnType;
                        }
                        $m->addComment('@return ' . implode('|', $types));
                    }
                } else if ($this->autoGenerateDocBlocks) {
                    $nodes = $method->getBody()->getNodes();
                    foreach ($nodes as $node) {
                        if ($node instanceof Node && $node->getType() === Return_::class) {
                            $params = $node->getParams();
                            if ($params[0] instanceof ResultTypeInterface) {
                                $m->addComment('@return ' . (string) $params[0]->getResultType());
                            } else {
                                $m->addComment('@return mixed');
                            }
                        }
                    }
                }

                $m->setNodes($method->getBody()->getNodes());
            }
        }
    }

    protected function getConstructor(\JDWil\PhpGenny\Type\Class_ $class): Method
    {
        foreach ($class->getMethods() as $method) {
            if ($method->getName() === '__construct') {
                return $method;
            }
        }

        $method = new Method('__construct');
        $class->addMethod($method);

        return $method;
    }

    protected function collectClassUseStatements(\JDWil\PhpGenny\Type\Class_ $class)
    {
        $ret = [];

        foreach ($class->getProperties() as $property) {
            if (($default = $property->getDefaultValue()) &&
                $default instanceof \JDWil\PhpGenny\Type\Class_ &&
                $default->getNamespace() !== $class->getNamespace()
            ) {
                $ret[] = $default->getFqn();
            }
        }

        return $ret;
    }

    /**
     * @throws \Exception
     */
    protected function throwIfNotGlobalScope()
    {
        if (get_class($this) !== Builder::class) {
            throw new \Exception('namespace cannot be used in block scope.');
        }
    }
}
