<?php
/**
 * Copyright (c) 2017 JD Williams
 *
 * This file is part of PHP-Genny, a library built by JD Williams. PHP-Genny is free software; you can
 * redistribute it and/or modify it under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 3 of the License, or (at your option) any later version.
 *
 * PHP-Genny is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the
 * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
 * Public License for more details. You should have received a copy of the GNU Lesser General Public
 * License along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * You should have received a copy of the GNU General Public License along with Unify. If not, see
 * <http://www.gnu.org/licenses/>.
 */

declare(strict_types=1);

namespace JDWil\PhpGenny\Builder;

use JDWil\PhpGenny\Builder\Node\AbstractNode;
use JDWil\PhpGenny\Builder\Node\AssignmentOp;
use JDWil\PhpGenny\Builder\Node\HasNodeBehaviorInterface;
use JDWil\PhpGenny\Builder\Node\Namespace_;
use JDWil\PhpGenny\Builder\Node\NewInstance;
use JDWil\PhpGenny\Builder\Node\Node;
use JDWil\PhpGenny\Builder\Node\Parameter;
use JDWil\PhpGenny\Builder\Node\Reference;
use JDWil\PhpGenny\Builder\Node\ResultTypeInterface;
use JDWil\PhpGenny\Builder\Node\Scalar;
use JDWil\PhpGenny\Builder\Node\Traits\NodeBehaviorTrait;
use JDWil\PhpGenny\Builder\Node\Type;
use JDWil\PhpGenny\Builder\Node\Variable;
use JDWil\PhpGenny\Type\Class_;
use JDWil\PhpGenny\Type\HasMethodsInterface;
use JDWil\PhpGenny\Type\HasPropertiesInterface;
use JDWil\PhpGenny\Type\HasTraitsInterface;
use JDWil\PhpGenny\Type\Interface_;
use JDWil\PhpGenny\Type\Method;
use JDWil\PhpGenny\Type\NamespaceInterface;
use JDWil\PhpGenny\Type\Property;
use JDWil\PhpGenny\Type\Trait_;
use JDWil\PhpGenny\ValueObject\InternalType;
use JDWil\PhpGenny\ValueObject\Visibility;
use PhpParser\Node\Expr\MethodCall;
use PhpParser\Node\Param;
use PhpParser\Node\Stmt\Return_;
use PhpParser\Node\Stmt\Throw_;

class BuilderFactory implements HasNodeBehaviorInterface
{
    use NodeBehaviorTrait;

    /**
     * @var Builder
     */
    protected $builder;

    public function constructInterfaceBuilder(Interface_ $interface): Builder
    {
        $this->builder = new Builder();
        $this->builder->copyBehaviorFrom($this);

        $this->addStrictTypes();
        $ns = $this->generateNamespace($interface);

        $uses = [];
        foreach ($interface->getExtends() as $extend) {
            if ($extend->getNamespace() !== $interface->getNamespace() &&
                !in_array($extend->getNamespace(), $uses, true)
            ) {
                $uses[] = $extend->getNamespace();
            }
        }

        foreach ($uses as $use) {
            $ns->use($use);
        }

        if (!empty($uses)) {
            $ns->newLine();
        }

        $i = $ns->interface($interface->getName());
        $this->addConstants($interface->getConstants(), $i);

        $methods = $this->sortMethods($interface->getMethods());
        foreach ($methods as $index => $method) {
            $m = $i->method($method->getName());
            $this->addMethodParameters($method, $m);
            $this->addReturnTypes($method, $m);

            if ($index !== (count($methods) - 1)) {
                $i->lineBreak();
            }
        }

        return $this->builder;
    }

    /**
     * @param Class_ $class
     * @return Builder
     * @throws \Exception
     */
    public function constructClassBuilder(Class_ $class)
    {
        $this->builder = new Builder();
        $this->builder->copyBehaviorFrom($this);

        $this->addStrictTypes();
        $ns = $this->generateNamespace($class);

        $uses = array_unique($this->collectClassUseStatements($class));
        foreach ($uses as $use) {
            $ns->use($use);
        }

        if (!empty($uses)) {
            $ns->newLine();
        }

        if ($this->autoGenerateDocBlocks) {
            $ns->newLine();
        }

        $c = $ns->class($class->getName());

        if ($class->isAbstract()) {
            $c->makeAbstract();
        }

        if ($class->isFinal()) {
            $c->makeFinal();
        }

        if ($extends = $class->getExtends()) {
            if ($extends instanceof Class_) {
                $c->extends($extends->getName());
            } else {
                $c->extends($extends);
            }
        }

        $implements = $class->getImplements();
        if (!empty($implements)) {
            foreach ($implements as $i) {
                if ($i instanceof Interface_) {
                    $c->implements($i->getName());
                } else {
                    $c->implements($i);
                }
            }
        }

        $this->addTraits($class, $c);
        $this->addConstants($class->getConstants(), $c);
        $this->addProperties($class, $c);
        $this->addMethods($class, $c);

        return $this->builder;
    }

    /**
     * @param Trait_ $trait
     * @return Builder
     * @throws \Exception
     */
    public function constructTraitBuilder(Trait_ $trait): Builder
    {
        $this->builder = new Builder();
        $this->builder->copyBehaviorFrom($this);

        $this->addStrictTypes();
        $ns = $this->generateNamespace($trait);

        $uses = $this->collectTraitUseStatements($trait);
        foreach ($uses as $use) {
            $ns->use($use);
        }

        if (!empty($uses)) {
            $ns->newLine();
        }

        if ($this->autoGenerateDocBlocks) {
            $ns->newLine();
        }

        $t = $ns->trait($trait->getName());
        $this->addTraits($trait, $t);
        $this->addProperties($trait, $t);
        $this->addMethods($trait, $t);

        return $this->builder;
    }

    /**
     * @param Class_ $class
     * @param bool $generateIfDoesNotExist
     * @return Method|false
     */
    protected function getConstructor(Class_ $class, bool $generateIfDoesNotExist = true)
    {
        foreach ($class->getMethods() as $method) {
            if ($method->getName() === '__construct') {
                return $method;
            }
        }

        if (!$generateIfDoesNotExist) {
            return false;
        }

        $method = new Method('__construct');
        $class->addMethod($method);

        return $method;
    }

    /**
     * @param Class_ $class
     * @return string[]
     */
    protected function collectClassUseStatements(Class_ $class): array
    {
        $ret = [];

        $this->collectPropertyUseStatements($class, $ret);

        foreach ($class->getImplements() as $implement) {
            if ($implement instanceof Interface_) {
                $ret[] = $implement->getFqn();
            }
        }

        $this->collectUseTraitUseStatements($class, $ret);
        $ret = array_merge($ret, $this->collectMethodUseStatements($class));

        return $ret;
    }

    /**
     * @param Trait_ $trait
     * @return string[]
     */
    protected function collectTraitUseStatements(Trait_ $trait): array
    {
        $ret = [];

        $this->collectPropertyUseStatements($trait, $ret);
        $this->collectUseTraitUseStatements($trait, $ret);

        return $ret;
    }

    /**
     * @param Class_|Trait_ $o
     * @return array
     */
    protected function collectMethodUseStatements($o): array
    {
        $uses = [];

        foreach ($o->getMethods() as $method) {
            /** @var NewInstance[] $newInstances */
            $newInstances = $this->findRecursive($method->getBody()->getNodes(), [NewInstance::class]);
            foreach ($newInstances as $newInstance) {
                $type = $newInstance->getType();
                if ($type instanceof Class_ && $type->getNamespace() !== $o->getNamespace()) {
                    $uses[] = $type->getFqn();
                }
            }

            /** @var Reference[] $references */
            $references = $this->findRecursive($method->getBody()->getNodes(), [Reference::class]);
            foreach ($references as $reference) {
                if ($object = $reference->getReferenceObject()) {
                    if ($object->getNamespace() !== $o->getNamespace()) {
                        $uses[] = $object->getFqn();
                    }
                }
            }

            foreach ($method->getParameters() as $parameter) {
                $type = $parameter->getType();
                if ($type instanceof Class_ || $type instanceof Interface_) {
                    if ($type->getNamespace() !== $o->getNamespace()) {
                        $uses[] = $type->getFqn();
                    }
                }
            }

            foreach ($method->getThrows() as $thrown) {
                if ($thrown instanceof Class_) {
                    $uses[] = $thrown->getFqn();
                }
            }
        }

        return $uses;
    }

    /**
     * @param Class_|Trait_ $o
     * @param Method $method
     * @return array
     */
    protected function findThrows($o, Method $method): array
    {
        $throws = [];
        $toProcess = $method->getBody()->getNodes();
        $processedMethods = [];

        while (!empty($toProcess)) {
            $nodes = $this->findRecursive($toProcess, [Node::class]);

            $newNodesToProcess = [];

            /** @var Node $node */
            foreach ($nodes as $node) {
                if ($node->getType() === Throw_::class) {
                    $thrown = $node->getNodes()['params'][0];
                    if ($thrown instanceof NewInstance) {
                        $throws[] = $thrown->getType();
                    }
                } else if ($node->getType() === MethodCall::class) {
                    if (($m = $o->getMethodByName($node->getParams()[1])) && !\in_array($m->getName(), $processedMethods, true)) {
                        $newNodesToProcess = array_merge($newNodesToProcess, $m->getBody()->getNodes());
                        $processedMethods[] = $m->getName();
                    }
                }
            }

            $toProcess = $newNodesToProcess;
        }

        return $throws;
    }

    /**
     * @param array $nodes
     * @param array $types
     * @return array
     */
    protected function findRecursive(array $nodes, array $types): array
    {
        $results = [];

        foreach ($nodes as $node) {
            if (is_array($node)) {
                $results = array_merge($results, $this->findRecursive($node, $types));
            } else {
                foreach ($types as $type) {
                    if ($node instanceof $type) {
                        $results[] = $node;
                    }
                }
            }

            if ($node instanceof AbstractNode) {
                $results = array_merge($results, $this->findRecursive($node->getNodes(), $types));
            }
        }

        return $results;
    }

    private function addStrictTypes()
    {
        if ($this->useStrict) {
            $this
                ->builder
                ->declare('strict_types', Scalar::int(1))
                ->newLine();
        }
    }

    /**
     * @param NamespaceInterface $class
     * @return Builder|Namespace_
     * @throws \Exception
     */
    private function generateNamespace(NamespaceInterface $class)
    {
        return null !== $class->getNamespace() ?
            $this->builder->namespace($class->getNamespace()) :
            $this->builder;
    }

    /**
     * @param array $constants
     * @param \JDWil\PhpGenny\Builder\Node\Class_|\JDWil\PhpGenny\Builder\Node\Interface_ $c
     */
    private function addConstants($constants, $c)
    {
        if (!empty($constants)) {
            foreach ($constants as $index => $constant) {
                $cb = $c->constant($constant['name'], $constant['value']);
                if (null !== $constant['visibility']) {
                    switch ((string)$constant['visibility']) {
                        case Visibility::PUBLIC:
                            $cb->makePublic();
                            break;
                        case Visibility::PROTECTED:
                            $cb->makeProtected();
                            break;
                        case Visibility::PRIVATE:
                            $cb->makePrivate();
                            break;
                    }
                }

                if ($constant['static']) {
                    $cb->makeStatic();
                }

                if ($cb->hasComment() && $index !== (count($constants) - 1)) {
                    $c->lineBreak();
                }
            }

            $c->lineBreak();
        }
    }

    /**
     * @param Method[] $methods
     * @return Method[]
     */
    private function sortMethods(array $methods): array
    {
        usort($methods, function (Method $a, Method $b) {
            $visibility = [
                'public' => 0,
                'protected' => 1,
                'private' => 2
            ];

            if ($a->getName() === '__construct') {
                return -1;
            }

            if ($b->getName() === '__construct') {
                return 1;
            }

            if (((string) $a->getVisibility()) !== ((string) $b->getVisibility())) {
                return $visibility[(string) $a->getVisibility()] < $visibility[(string) $b->getVisibility()] ? -1 : 1;
            }

            return strcmp($a->getName(), $b->getName());
        });

        return $methods;
    }

    /**
     * @param Method $method
     * @param \JDWil\PhpGenny\Builder\Node\Method $m
     * @throws \Exception
     */
    private function addMethodParameters($method, $m)
    {
        $parameters = $method->getParameters();

        /**
         * Bubble up parameters without defaults to the front of the list.
         */
        usort($parameters, function (\JDWil\PhpGenny\Type\Parameter $p1, \JDWil\PhpGenny\Type\Parameter $p2) {
            if ($p1->getDefaultValue() !== null && $p2->getDefaultValue() === null) {
                return 1;
            }

            if ($p1->getDefaultValue() === null && $p2->getDefaultValue() !== null) {
                return -1;
            }

            return 0;
        });

        foreach ($parameters as $parameter) {
            $p = $this->builder->parameter($parameter->getName());

            if ($parameter->isVariadic()) {
                $p->makeVariadic();
            }

            if ($default = $parameter->getDefaultValue()) {
                if (is_string($default)) {
                    $default = Scalar::string($default);
                }
                $p->setDefault($default);
            }

            if ($type = $parameter->getType()) {
                $p->setType($type);
            }

            $m->add($p);

            if ($this->autoGenerateDocBlocks) {
                $type = $parameter->getType() ?? InternalType::mixed();
                $typeString = (string) $type;
                if ($type instanceof InternalType) {
                    $typeString = $type->getDocblockString();
                }

                $default = $parameter->getDefaultValue();
                $null = '';
                if (!$default instanceof Type || $default->getType() !== Type::ARRAY) {
                    $null = null === $default ? '' : '|null';
                }
                $m->addComment('@param ' . $typeString . $null . ' $' . $parameter->getName());
            }
        }
    }

    /**
     * @param Method $method
     * @param \JDWil\PhpGenny\Builder\Node\Method $m
     */
    private function addReturnTypes($method, $m)
    {
        $returnTypes = $method->getReturnTypes();
        if (!empty($returnTypes)) {
            if (count($returnTypes) === 1) {
                $m->setReturnType($returnTypes[0]);
                $m->addComment('@return ' . (string)$returnTypes[0]);
            } else if (
                count($returnTypes) === 2 &&
                (
                    ((string)$returnTypes[0]) === 'null' ||
                    ((string)$returnTypes[1]) === 'null'
                )
            ) {
                $nonNullType = (string)$returnTypes[0] === 'null' ?
                    $returnTypes[1] :
                    $returnTypes[0];
                if ($this->phpTargetVersion > Builder::PHP_70) {
                    $m->setReturnType($nonNullType, true);
                }
                $m->addComment('@return ' . (string)$nonNullType . '|null');
            } else {
                $types = [];
                foreach ($returnTypes as $returnType) {
                    $types[] = (string)$returnType;
                }
                $m->addComment('@return ' . implode('|', $types));
            }
        } else if ($this->autoGenerateDocBlocks) {
            $nodes = $method->getBody()->getNodes();
            $types = $this->analyzeMethodTypes($method);
            foreach ($nodes as $node) {
                if ($node instanceof Node &&
                    $node->getType() === Return_::class &&
                    ($type = $this->findReturnType($node->getNodes(), $types))
                ) {
                    $m->addComment('@return ' . (string) $type);
                }
            }
        }
    }

    /**
     * @param Method $method
     * @return array
     */
    private function analyzeMethodTypes(Method $method): array
    {
        $types = [];

        foreach ($method->getParameters() as $parameter) {
            if ($type = $parameter->getType()) {
                $types[$parameter->getName()] = (string) $type;
            } else if ($default = $parameter->getDefaultValue()) {
                if ($default instanceof ResultTypeInterface) {
                    $types[$parameter->getName()] = $default->getResultType();
                }
            }
        }

        $this->analyzeNodes($method->getBody()->getNodes(), $types);

        return $types;
    }

    private function analyzeNodes(array $nodes, array &$types)
    {
        foreach ($nodes as $node) {
            if (is_array($node)) {
                $this->analyzeNodes($node, $types);
            }

            if ($node instanceof AssignmentOp) {
                $n = $node->getNodes();
                $variable = $n['variable'];
                $value = $n['value'];
                if ($value instanceof ResultTypeInterface && $variable instanceof Variable) {
                    $types[$variable->getName()] = $value->getResultType();
                }
            }
        }
    }

    /**
     * @param array $nodes
     * @param array $types
     * @return mixed
     */
    private function findReturnType(array $nodes, array $types)
    {
        foreach ($nodes as $node) {
            if (is_array($node) && ($type = $this->findReturnType($node, $types))) {
                return $type;
            }

            if ($node instanceof Variable) {
                if (isset($types[$node->getName()])) {
                    return $types[$node->getName()];
                }
            } else if ($node instanceof ResultTypeInterface) {
                return $node->getResultType();
            }
        }

        return false;
    }

    /**
     * @param HasTraitsInterface $o
     * @param \JDWil\PhpGenny\Builder\Node\Class_|\JDWil\PhpGenny\Builder\Node\Trait_ $n
     * @throws \Exception
     */
    private function addTraits(HasTraitsInterface $o, $n)
    {
        foreach ($o->getTraits() as $trait) {
            $tu = $n->use($trait->getName());
            foreach ($o->getPrecedences() as $precedence) {
                $tu->use($precedence['trait'], $precedence['method'])->insteadOf(array_map(function (Trait_ $t) {
                    return $t->getName();
                }, $precedence['otherTraits']));
            }

            foreach ($o->getAlias() as $alias) {
                $tu->alias($alias['trait'], $alias['method'])->as($alias['newName'], $alias['visibility']);
            }
        }
    }

    /**
     * @param HasPropertiesInterface $o
     * @param $ret
     */
    protected function collectPropertyUseStatements(HasPropertiesInterface $o, &$ret)
    {
        /** @var Property $property */
        foreach ($o->getProperties() as $property) {
            if (($default = $property->getDefaultValue()) &&
                $default instanceof Class_ &&
                $default->getNamespace() !== $o->getNamespace()
            ) {
                $ret[] = $default->getFqn();
            }

            foreach ($property->getTypes() as $type) {
                if (($type instanceof Class_ || $type instanceof Interface_) &&
                    $type->getNamespace() !== $o->getNamespace()
                ) {
                    $ret[] = $type->getFqn();
                }
            }
        }
    }

    /**
     * @param HasTraitsInterface $class
     * @param $ret
     */
    protected function collectUseTraitUseStatements(HasTraitsInterface $class, &$ret)
    {
        foreach ($class->getTraits() as $trait) {
            if ($trait->getNamespace() !== $class->getNamespace()) {
                $ret[] = $trait->getFqn();
            }
        }
    }

    /**
     * @param HasPropertiesInterface $o
     * @param \JDWil\PhpGenny\Builder\Node\Class_|\JDWil\PhpGenny\Builder\Node\Trait_ $n
     */
    protected function addProperties(HasPropertiesInterface $o, $n)
    {
        $properties = $o->getProperties();
        if (!empty($properties)) {
            foreach ($properties as $index => $property) {
                $p = $n->property($property->getName());
                if ($this->preferDefaultsSetInConstructor) {
                    if ($o instanceof Class_) {
                        if ($default = $property->getDefaultValue()) {
                            if ($default instanceof Class_) {
                                $p->setType($default);
                                $constructor = $this->getConstructor($o);
                                $constructor->getBody()->execute(
                                    Variable::named('this')->property($property->getName())->equals(NewInstance::of($default->getName()))
                                );
                            } else if ($default instanceof AbstractNode) {
                                if ($default instanceof ResultTypeInterface) {
                                    $p->setType($default->getResultType());
                                }
                                $constructor = $this->getConstructor($o);
                                $constructor->getBody()->execute(
                                    Variable::named('this')->property($property->getName())->equals($default)
                                );
                            }
                        }
                    }
                } else if (($default = $property->getDefaultValue()) && $default instanceof AbstractNode) {
                    $p->setDefault($default);
                }

                switch ((string) $property->getVisibility()) {
                    case Visibility::PUBLIC:
                        $p->makePublic();
                        break;
                    case Visibility::PROTECTED:
                        $p->makeProtected();
                        break;
                    case Visibility::PRIVATE:
                        $p->makePrivate();
                        break;
                }

                if ($t = $property->getType()) {
                    $p->setType($t, $property->isNullable());
                }

                if ($p->hasComment() && $index !== (count($properties) - 1)) {
                    $n->lineBreak();
                }
            }

            $n->lineBreak();
        }
    }

    /**
     * @param HasMethodsInterface $o
     * @param \JDWil\PhpGenny\Builder\Node\Class_|\JDWil\PhpGenny\Builder\Node\Trait_ $n
     */
    protected function addMethods(HasMethodsInterface $o, $n)
    {
        $methods = $this->sortMethods($o->getMethods());

        if (!empty($methods)) {
            foreach ($methods as $index => $method) {
                $m = $n->method($method->getName());

                if ($this->autoGenerateDocBlocks && $method->getName() === '__construct') {
                    $m->addComment($o->getName() . ' constructor.');
                    $m->addComment('');
                }

                switch ((string) $method->getVisibility()) {
                    case Visibility::PROTECTED:
                        $m->makeProtected();
                        break;

                    case Visibility::PRIVATE:
                        $m->makePrivate();
                        break;

                    default:
                        $m->makePublic();
                        break;
                }

                $this->addMethodParameters($method, $m);
                $this->addReturnTypes($method, $m);

                $m->setNodes($method->getBody()->getNodes());

                if ($this->autoGenerateDocBlocks) {
                    $added = [];
                    foreach (array_unique($this->findThrows($o, $method)) as $thrown) {
                        if ($thrown instanceof Class_) {
                            $m->addComment('@throws ' . $thrown->getName());
                            $added[] = $thrown->getName();
                        }
                    }

                    foreach ($method->getThrows() as $thrown) {
                        if ($thrown instanceof Class_) {
                            $thrown = $thrown->getName();
                        }

                        if (!\in_array($thrown, $added, true)) {
                            $m->addComment('@throws ' . $thrown);
                            $added[] = $thrown;
                        }
                    }
                }

                if ($index !== (count($methods) - 1)) {
                    $n->lineBreak();
                }
            }
        }
    }
}
